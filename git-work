#!/usr/bin/env bash
# git-work
# Quick workflow helper: stage everything → smart commit message (Gemini AI if key set) → optional push
# Version: 0.2.1-gemini (January 2026)

set -euo pipefail

# ─── CONFIGURATION ───────────────────────────────────────────────────────────
DEFAULT_REMOTE="origin"
AUTO_PUSH=true                  # set to false to disable auto-push
USE_AI=true                     # set to false to always use simple fallback

GEMINI_MODEL="gemini-2.5-flash"   # fast & reliable in Jan 2026
# ─── HELP ────────────────────────────────────────────────────────────────────
show_help() {
    cat <<'EOF'
git work [options]

Stage all → smart commit message (Gemini AI if API key set) → commit → (optional) push

Options:
  --no-push        Commit but do NOT push
  --no-ai          Force simple rule-based message
  --help, -h       Show this help
  --dry-run        Show what would happen without making changes

Setup for AI:
  export GEMINI_API_KEY="your-key-from-aistudio.google.com"

Examples:
  git work
  git work --no-push
EOF
    exit 0
}

# ─── ARGUMENT PARSING ────────────────────────────────────────────────────────
DRY_RUN=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)      show_help ;;
        --dry-run)      DRY_RUN=true; shift ;;
        --no-push)      AUTO_PUSH=false; shift ;;
        --no-ai)        USE_AI=false; shift ;;
        *)              echo "Unknown option: $1" >&2; exit 1 ;;
    esac
done

# ─── SAFETY CHECKS ───────────────────────────────────────────────────────────
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "error: not inside a git repository" >&2
    exit 1
fi

CURRENT_BRANCH=$(git branch --show-current)
if [[ -z "$CURRENT_BRANCH" ]]; then
    echo "error: cannot detect current branch (detached HEAD?)" >&2
    exit 1
fi

if [[ "$CURRENT_BRANCH" == "main" || "$CURRENT_BRANCH" == "master" ]]; then
    echo "⚠️  You are on main/master branch!"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
fi

# ─── CHECK IF THERE IS ANYTHING TO COMMIT ────────────────────────────────────
if [[ -z "$(git status --porcelain --untracked-files=all)" ]]; then
    echo "Nothing to commit."
    exit 0
fi

# ─── STAGE ───────────────────────────────────────────────────────────────────
echo "→ Staging all changes..."
if $DRY_RUN; then
    echo "   (dry-run) git add -A"
else
    git add -A
fi

# ─── COMMIT MESSAGE FUNCTIONS ────────────────────────────────────────────────

generate_fallback_message() {
    local file_count=$(git diff --cached --name-only | wc -l | tr -d ' ')
    local stats=$(git diff --cached --stat | tail -n 1 | sed 's/^[[:space:]]*//')
    local main_file=$(git diff --cached --name-only | head -n 1 | xargs basename 2>/dev/null || echo "files")

    if [ "$file_count" -eq 0 ]; then
        echo "chore: empty commit $(date +'%Y-%m-%d %H:%M')"
    elif [ "$file_count" -eq 1 ]; then
        echo "chore: update ${main_file}"
    elif [ "$file_count" -le 3 ]; then
        echo "chore: updates across ${file_count} files"
    else
        echo "chore: multiple changes - ${stats}"
    fi
}

generate_gemini_message() {
    local diff_content="$1"

    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        echo "Gemini API key not found" >&2
        return
    fi

    echo "→ Using Google Gemini API (${GEMINI_MODEL})..." >&2

    # 1. Use jq to build the JSON safely. This handles newlines/quotes in diff_content automatically.
    local json_payload
    json_payload=$(jq -n \
        --arg diff "$diff_content" \
        --arg model "$GEMINI_MODEL" \
        '{
            contents: [{
                parts: [{
                    text: ("Generate EXACTLY ONE conventional commit message for these changes. Output NOTHING ELSE — no explanations, no lists, no quotes. \n\nFormat strictly: type(scope): description\nTypes: feat, fix, refactor, perf, style, test, docs, build, ci, chore, revert\nMax 72 chars.\n\nAnalyze the following git diff and write a specific message:\n" + $diff)
                }]
            }],
            generationConfig: {
                temperature: 0.1,
                maxOutputTokens: 128
            }
        }')

    # 2. Send request
    local response
    response=$(curl -s -X POST \
        "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    # 3. Parse response
    local generated_text
    generated_text=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null)

    # 4. Clean the output (remove markdown code blocks if Gemini adds them)
    local cleaned
    cleaned=$(echo "$generated_text" \
        | sed 's/```.*//g' \
        | sed 's/^["'\'' ]*//; s/["'\'' ]*$//' \
        | tr -d '\n\r' \
        | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # 5. Robust Validation using Regex
    # Matches: type followed by optional (scope), a colon, space, then text.
    if [[ "$cleaned" =~ ^(feat|fix|refactor|perf|style|test|docs|build|ci|chore|revert)(\(.*\))?:[[:space:]].+ ]]; then
        echo "$cleaned"
    else
        # If debug is needed, uncomment the next line to see what Gemini actually sent
        # echo "DEBUG: Gemini sent: [$cleaned]" >&2
        echo "Gemini response doesn't look like conventional commit" >&2
    fi
}

# ─── DECIDE MESSAGE ──────────────────────────────────────────────────────────
# Capture the actual diff (limit to ~100KB to stay within safe shell/API limits)
# We use 'git diff --cached' to see what is staged.
RAW_DIFF=$(git diff --cached | head -c 100000)

# If we truncated, add a note so AI knows
if [ ${#RAW_DIFF} -ge 100000 ]; then
    RAW_DIFF="${RAW_DIFF}\n... (diff truncated)"
fi

if $USE_AI && [ -n "$RAW_DIFF" ]; then
    AI_MSG=$(generate_gemini_message "$RAW_DIFF")
    if [ -n "$AI_MSG" ]; then
        COMMIT_MSG="$AI_MSG"
    else
        echo "warning: Gemini unavailable or failed → using fallback" >&2
        COMMIT_MSG=$(generate_fallback_message)
    fi
else
    COMMIT_MSG=$(generate_fallback_message)
fi

echo
echo "Commit message:"
echo "  $COMMIT_MSG"
echo

if $DRY_RUN; then
    echo "(dry-run mode - no real changes made)"
    exit 0
fi

# ─── CONFIRMATION & COMMIT & PUSH ───────────────────────────────────────────
read -p "→ Commit ${AUTO_PUSH:+& push}? [Y/n/e(edit)] " -n 1 -r choice
echo

case $choice in
    ""|y|Y|yes) ;;
    e|E|edit)
        echo "Enter your commit message:"
        COMMIT_MSG=$(cat)
        ;;
    *) echo "Cancelled."; exit 0 ;;
esac

echo "→ Creating commit..."
git commit -m "$COMMIT_MSG"

if $AUTO_PUSH; then
    echo "→ Pushing to ${DEFAULT_REMOTE} ${CURRENT_BRANCH}..."
    git push "${DEFAULT_REMOTE}" "${CURRENT_BRANCH}"
    echo
    echo "Done! ✓"
else
    echo "Commit created. Push when ready."
fi