#!/usr/bin/env bash
# git-work
# Quick workflow helper: stage everything → smart commit message (Gemini AI if key set) → optional push
# Version: 0.2.1-gemini (January 2026)

set -euo pipefail

# ─── CONFIGURATION ───────────────────────────────────────────────────────────
DEFAULT_REMOTE="origin"
AUTO_PUSH=true                  # set to false to disable auto-push
USE_AI=true                     # set to false to always use simple fallback

GEMINI_MODEL="gemini-2.5-flash"   # fast & reliable in Jan 2026
# ─── HELP ────────────────────────────────────────────────────────────────────
show_help() {
    cat <<'EOF'
git work [options]

Stage all → smart commit message (Gemini AI if API key set) → commit → (optional) push

Options:
  --no-push        Commit but do NOT push
  --no-ai          Force simple rule-based message
  --help, -h       Show this help
  --dry-run        Show what would happen without making changes

Setup for AI:
  export GEMINI_API_KEY="your-key-from-aistudio.google.com"

Examples:
  git work
  git work --no-push
EOF
    exit 0
}

# ─── ARGUMENT PARSING ────────────────────────────────────────────────────────
DRY_RUN=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)      show_help ;;
        --dry-run)      DRY_RUN=true; shift ;;
        --no-push)      AUTO_PUSH=false; shift ;;
        --no-ai)        USE_AI=false; shift ;;
        *)              echo "Unknown option: $1" >&2; exit 1 ;;
    esac
done

# ─── SAFETY CHECKS ───────────────────────────────────────────────────────────
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "error: not inside a git repository" >&2
    exit 1
fi

CURRENT_BRANCH=$(git branch --show-current)
if [[ -z "$CURRENT_BRANCH" ]]; then
    echo "error: cannot detect current branch (detached HEAD?)" >&2
    exit 1
fi

if [[ "$CURRENT_BRANCH" == "main" || "$CURRENT_BRANCH" == "master" ]]; then
    echo "⚠️  You are on main/master branch!"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
fi

# ─── CHECK IF THERE IS ANYTHING TO COMMIT ────────────────────────────────────
if [[ -z "$(git status --porcelain --untracked-files=all)" ]]; then
    echo "Nothing to commit."
    exit 0
fi

# ─── STAGE ───────────────────────────────────────────────────────────────────
echo "→ Staging all changes..."
if $DRY_RUN; then
    echo "   (dry-run) git add -A"
else
    git add -A
fi

# ─── COMMIT MESSAGE FUNCTIONS ────────────────────────────────────────────────

generate_fallback_message() {
    local file_count=$(git diff --cached --name-only | wc -l | tr -d ' ')
    local stats=$(git diff --cached --stat | tail -n 1 | sed 's/^[[:space:]]*//')
    local main_file=$(git diff --cached --name-only | head -n 1 | xargs basename 2>/dev/null || echo "files")

    if [ "$file_count" -eq 0 ]; then
        echo "chore: empty commit $(date +'%Y-%m-%d %H:%M')"
    elif [ "$file_count" -eq 1 ]; then
        echo "chore: update ${main_file}"
    elif [ "$file_count" -le 3 ]; then
        echo "chore: updates across ${file_count} files"
    else
        echo "chore: multiple changes - ${stats}"
    fi
}

generate_gemini_message() {
    local diff_content="$1"

    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        echo "Gemini API key not found" >&2
        echo ""
        return
    fi

    echo "→ Using Google Gemini API (${GEMINI_MODEL})..." >&2

    local prompt="Create a concise conventional commit message (max 72 chars) for these code changes. Format exactly: type(scope): description. Allowed types: feat, fix, refactor, perf, style, test, docs, build, ci, chore, revert. Be specific and meaningful based on the diff. No period at the end. Output ONLY the commit message, nothing else.\n\nChanges:\n${diff_content}"

    local response
    response=$(curl -s -X POST \
        "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent" \
        -H "Content-Type: application/json" \
        -H "x-goog-api-key: ${GEMINI_API_KEY}" \
        -d '{
          "contents": [{
            "parts": [{
              "text": "'"${prompt}"'"
            }]
          }],
          "generationConfig": {
            "temperature": 0.3,
            "maxOutputTokens": 80
          }
        }' || echo "")

    local generated_text
    generated_text=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null)

    # Clean the output
    local cleaned
    cleaned=$(echo "$generated_text" \
        | sed 's/^["'\'' ]*//; s/["'\'' ]*$//; s/\\n.*//g' \
        | tr -d '\n\r' \
        | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    if [[ -n "$cleaned" && ${#cleaned} -le 80 && "$cleaned" =~ ^(feat|fix|refactor|perf|style|test|docs|build|ci|chore|revert)(\([^)]+\))?: ]]; then
        echo "$cleaned"
    else
        echo "Gemini response invalid or empty" >&2
        echo ""
    fi
}

# ─── DECIDE MESSAGE ──────────────────────────────────────────────────────────
DIFF=$(git diff --cached)

if $USE_AI && [ -n "$DIFF" ]; then
    AI_MSG=$(generate_gemini_message "$DIFF")
    if [ -n "$AI_MSG" ] && [ ${#AI_MSG} -le 80 ]; then
        COMMIT_MSG="$AI_MSG"
    else
        echo "warning: Gemini unavailable or failed → using fallback" >&2
        COMMIT_MSG=$(generate_fallback_message)
    fi
else
    COMMIT_MSG=$(generate_fallback_message)
fi

echo
echo "Commit message:"
echo "  $COMMIT_MSG"
echo

if $DRY_RUN; then
    echo "(dry-run mode - no real changes made)"
    exit 0
fi

# ─── CONFIRMATION & COMMIT & PUSH ───────────────────────────────────────────
read -p "→ Commit ${AUTO_PUSH:+& push}? [Y/n/e(edit)] " -n 1 -r choice
echo

case $choice in
    ""|y|Y|yes) ;;
    e|E|edit)
        echo "Enter your commit message:"
        COMMIT_MSG=$(cat)
        ;;
    *) echo "Cancelled."; exit 0 ;;
esac

echo "→ Creating commit..."
git commit -m "$COMMIT_MSG"

if $AUTO_PUSH; then
    echo "→ Pushing to ${DEFAULT_REMOTE} ${CURRENT_BRANCH}..."
    git push "${DEFAULT_REMOTE}" "${CURRENT_BRANCH}"
    echo
    echo "Done! ✓"
else
    echo "Commit created. Push when ready."
fi